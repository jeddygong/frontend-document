### 什么是闭包

​	函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。

​	可以在内部函数访问到外部函数的作用域。

​	使用闭包，一可以读取函数中的变量，二可以将函数中的变量存储在内存中，保护变量不被污染。而正因为闭包会把函数中的变量值存储在内存中，会对内存有消耗，所以不能滥用闭包，否则会影响网页性能，造成内存泄露。当不需要使用闭包时，要及时释放内存，可将内存函数对象的变量赋值为null。



### 闭包原理

 * 函数执行分成两个阶段（预编译阶段和执行阶段）
   	* 在预编译阶段：如果发现内部函数使用了外部函数的变量，则会在内存中创建一个“闭包”对象并保存对应变量值，如果已存在“闭包”，则只需要增加对应属性值即可。
   	* 执行完后，函数执行上下文会被销毁，函数对“闭包”对象的引用也会被销毁，但其内部函数还持有该“闭包“的引用，所以内部函数可以继续使用“外部函数”中的变量。
* 利用了函数的作用域链的特性，一个函数内部定义的函数会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链仍然在引用这个活动对象，所以其活动对象不会被销毁，知道内部函数被销毁后才被销毁。



### 优点

* 可以从内部函数访问外部函数的作用域中的变量，且访问的变量长期驻扎在内存中，可供之后使用；
* 避免变量污染全局
* 把变量存到独立的作用域，作为私有成员存在；



### 缺点

* 对内存消耗有负面影响。因为内部函数保存了对外部变量的引用，导致无法被GA回收，增大内存使用量，所以使用不当会导致内存泄露；
* 对处理速度具有负面影响，闭包的层级觉得了引用的外部变量在查找时经过的作用域链长度；
* 可能获取到意外的值（captured value）；



### 应用场景

#### 一、典型应用是模块封装，在各个模块规范出现之前，都是用这样的方式防止变量污染全局。

```javascript
var example = (function () {
  // 这样声明为模块私有变量，外界无法直接访问；
  var a = 0;
  function example1 () {}
  example1.prototype.nav = function nav() {
    return a;
  }
  return example1;
} ())
```

	#### 二、在循环中创建闭包，防止取到意外的值。

​	如下所示，无论哪个元素触发事件，都会弹3.因为函数执行后引用的i是同一个i，而i在循环结束后就是3

```javascript
for (var i = 0; i < 3; i++) {
	document.getElementById('id'+i).onfocus = function () {
    alert(i);
  }
}

// 可用闭包解决
function callBack (n) {
  return function () {
    alert()n
  }
}
for (var i =0; i < 3; i ++) {
  document.getElementById('id'+i).onfocus = callBack(i);
}
```

